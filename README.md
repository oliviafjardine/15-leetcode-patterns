# 15-leetcode-patterns

1. Prefix Sum
2. Sliding Window
3. Two Pointers
4. Binary Search
5. DFS/BFS/Backtracking
6. Union Find
7. Dynamic Programming (DP)
8. Greedy Algorithm
9. Sorting and Searching Algorithms
10. Stack, Queue, Heap/Priority Queue
11. Linked List Operations
12. Tree Traversal & BST operations
13. Graph Theory Concepts
14. Bit Manipulation
15. Math Problems 

## Plan
📅 Overview: 8-Week Mastery Plan

Week	Focus
1	Python fundamentals (bare minimum for LeetCode)
2	Essential data structures in Python
3	Sliding Window, Two Pointers, Fast & Slow Pointers
4	Binary Search (Classic & on Answer), BFS/DFS
5	Backtracking, Subsets, Permutations, Bitmask
6	Stack/Monotonic Stack, Greedy, Intervals
7	Dynamic Programming (1D/2D/Knapsack/Decision Trees)
8	Graphs (Topological Sort, Union-Find, Dijkstra), Mock Interviews
✅ Week 1: Python Fundamentals for LeetCode

Goal: Build the minimum Python foundation to read/write LeetCode code.

✅ Topics:
Variables, loops, conditionals
Functions
List operations (append, pop, slicing, etc.)
Dictionary, Set
Tuples and immutability
String operations
Comprehensions
Basic recursion
Exception handling
Reading input/output (just for completeness)
🔁 Practice:
HackerRank Python track
PythonTutor for visualizing code flow
✅ Week 2: Core Data Structures in Python

Goal: Know the basic tools you’ll use in every problem.

✅ Topics:
Arrays/Lists
Dictionaries (Hash Maps)
Sets
Tuples
Stacks/Queues (collections.deque)
Heaps (heapq)
Custom Classes and __lt__ for sorting/priority queue
Built-in functions: sorted, enumerate, zip, map, filter
🔁 Practice:
Implement:
Stack via list
Queue via deque
Min Heap and Max Heap
Trie (basic)
LeetCode Easy: Top 50 questions (focus on implementation)
✅ Week 3: Pattern 1–3

Sliding Window | Two Pointers | Fast & Slow Pointers

🔑 Core Idea:
All about using fixed or dynamic windows or pairs of pointers for optimized traversal.

✅ Must-Do Problems:
Sliding Window:
Maximum Subarray Sum
Longest Substring Without Repeating Characters
Two Pointers:
Two Sum II
3Sum
Container With Most Water
Fast & Slow Pointers:
Linked List Cycle
Middle of Linked List
Happy Number
🔁 Practice:
Solve 1–2 problems per pattern daily.
For each, ask: “Why not brute force? How do pointers help?”
✅ Week 4: Pattern 4–5

Binary Search | BFS & DFS

🔑 Core Idea:
Use divide-and-conquer or tree/graph traversal to efficiently explore possibilities.

✅ Must-Do Problems:
Binary Search:
Search in Rotated Array
Koko Eating Bananas
Find Peak Element
BFS/DFS:
Number of Islands
Clone Graph
Word Ladder
🔁 Practice:
Implement DFS recursively and iteratively
Implement BFS with queue
Use “binary search on answer” pattern
✅ Week 5: Pattern 6–8

Backtracking | Subsets | Permutations

🔑 Core Idea:
Explore decision trees by trying all possibilities (recursion + pruning).

✅ Must-Do Problems:
Backtracking:
N-Queens
Sudoku Solver
Subsets/Combinations:
Subsets I & II
Combination Sum
Permutations:
Permutations I & II
🔁 Practice:
Draw recursion trees
Trace call stack in PythonTutor
Understand base/recursive case clearly
✅ Week 6: Pattern 9–11

Stack & Monotonic Stack | Greedy | Intervals

🔑 Core Idea:
Use data structures or greedy choices to make optimal decisions.

✅ Must-Do Problems:
Stack:
Valid Parentheses
Daily Temperatures
Monotonic Stack:
Largest Rectangle in Histogram
Greedy:
Jump Game
Gas Station
Intervals:
Merge Intervals
Non-overlapping Intervals
🔁 Practice:
Implement from scratch
Think: “Can I solve this greedily or is it DP?”
✅ Week 7: Pattern 12–14

Dynamic Programming

🔑 Core Idea:
Break problem into overlapping subproblems, cache answers.

✅ Topics:
1D DP: Fibonacci, Climbing Stairs, House Robber
2D DP: Unique Paths, Edit Distance
Knapsack: 0/1, Unbounded
Decision Tree DP: Coin Change, Palindrome Partitioning
🔁 Practice:
Write recurrence relation before coding
Build bottom-up tables and trace solutions
✅ Week 8: Pattern 15 + Final Review

Graphs: Topological Sort, Union-Find, Dijkstra

✅ Topics:
Topological Sort: Course Schedule
Union Find (DSU): Accounts Merge, Graph Valid Tree
Dijkstra’s Algorithm: Network Delay Time
🔁 Practice:
Implement:
DSU with path compression
Graph with adjacency list
BFS/DFS/Topo Sort
Do 3–4 mock interviews from LeetCode Discuss or NeetCode list
📈 Daily Time Commitment

Weekdays: 1–2 hours (learn + 1–2 problems)
Weekends: 2–4 hours (review + focused problem sets)
Daily Plan Example:
20 min review notes
40 min learn new pattern/problem
1 hour solving + explaining code